### Se busca no rechazar, es decir,
### que sea plausible (no se encontró evidencia en contra) asumir que la varianza no depende de forma lineal de x
### i.e. p-value mayor a significancia.
#Usa residuales studentilizados
library(lmtest)
lmtest::bptest(fit)
#Usa residuales estandarizados
library(car)
car::ncvTest(fit)
summary(Datos$nassets)
#Se prefiere un valor de lambda conocido para no complicar mucho la interpretaci?n
summary(powerTransform(fit))
Datos$nassets_lambda0=bcPower(Datos$nassets, .2)
Datos$nassetsBC=(Datos$nassets^(.2)-1)/.2
par(mar=c(4, 5, 1, 1))
par(mfrow=c(1,1))
plot(Datos$stfees, Datos$nassetsBC, xlab = TeX("$stfees$"), ylab=TeX("$(y^{.2}-1)/.2$") )
rm(list = ls(all.names = TRUE))
gc()
library(Ecdat)
Datos <- University
help(University)
head(Datos)
str(Datos)
library(latex2exp)
par(mfrow=c(1,1))
par(mar=c(4, 5, 1, 1))
plot(Datos$stfees, Datos$nassets, xlab = TeX("$stfees$"), ylab=TeX("$nassets$") )
fit=lm(nassets~stfees, data=Datos)
summary(fit)
par(mfrow=c(1,1))
par(mar=c(4, 5, 1, 1))
plot(fit, 3)
library(broom)
Datosfit=augment(fit)
head(Datosfit)
par(mar=c(4, 5, 1, 1))
par(mfrow=c(1,1))
plot(Datosfit$.fitted, Datosfit$.std.resid, xlab = TeX("$\\widehat{y}$"), ylab=TeX("$e_{s}$")   )
### Pruebas de hipótesis
### H0: varianza no depende de forma lineal en x vs  Ha: varianza depende de forma lineal en x
### Se busca no rechazar, es decir,
### que sea plausible (no se encontró evidencia en contra) asumir que la varianza no depende de forma lineal de x
### i.e. p-value mayor a significancia.
#Usa residuales studentilizados
library(lmtest)
lmtest::bptest(fit)
#Usa residuales estandarizados
library(car)
car::ncvTest(fit)
summary(Datos$nassets)
#Se prefiere un valor de lambda conocido para no complicar mucho la interpretaci?n
summary(powerTransform(fit))
Datos$nassets_lambda0=bcPower(Datos$nassets, .2)
Datos$nassetsBC=(Datos$nassets^(.2)-1)/.2
par(mar=c(4, 5, 1, 1))
par(mfrow=c(1,1))
plot(Datos$stfees, Datos$nassetsBC, xlab = TeX("$stfees$"), ylab=TeX("$(y^{.2}-1)/.2$") )
fit2=lm(nassetsBC~stfees, data=Datos)
summary(fit2)
par(mfrow=c(1,1))
par(mar=c(4, 5, 1, 1))
plot(fit2, 3)
lmtest::bptest(fit2)
car::ncvTest(fit2)
summary(powerTransform(fit2))
par(mfrow=c(1,2))
par(mar=c(4, 5, 1, 1))
fit2yprima <- function(X2) {fit2$coef[1]+ fit2$coef[2]*X2}
fit2y <- function(X2) {((fit2$coef[1]+ fit2$coef[2]*X2)*.2+1)^5}
# En la escala transformada la curva (recta) corresponde
# a la estimación de E(y*;x)=Med(y*;x)
plot(Datos$stfees,Datos$nassetsBC, xlab = TeX("$stfees$"), ylab=TeX("$y^{*}$") )
curve(fit2yprima, from = min(Datos$stfees), to = max(Datos$stfees),
col = "red", add = T)
# En la escala original la curva corresponde
# a la estimación de Med(y;x)
plot(Datos$stfees, Datos$nassets, xlab = TeX("$stfees$"), ylab=TeX("$nassets$") )
curve(fit2y, from = min(Datos$stfees), to = max(Datos$stfees),
col = "red", add = T)
rm(list = ls(all.names = TRUE))
gc()
setwd("~/GitHub/Notas 2024-2/MNPyR")
Datos = read.csv("initech.csv")
head(Datos)
str(Datos)
library(latex2exp)
par(mfrow=c(1,2))
par(mar=c(4, 5, 1, 1))
plot(Datos$years, Datos$salary, xlab = TeX("$X=years$"), ylab=TeX("$salary$") )
plot((Datos$years+10)^2, Datos$salary, xlab = TeX("$X'=(years+10)^2$"), ylab=TeX("$salary$") )
Datos$Xprima=(Datos$years+10)^2
fit=lm(salary~Xprima, data=Datos)
summary(fit)
par(mfrow=c(1,1))
par(mar=c(4, 5, 1, 1))
plot(fit, 3)
lmtest::bptest(fit)
car::ncvTest(fit)
library(broom)
Datosfit=augment(fit)
head(Datosfit)
par(mar=c(4, 5, 1, 1))
par(mfrow=c(1,2))
plot(Datosfit$.fitted, Datosfit$.std.resid, xlab = TeX("$\\widehat{y}$"), ylab=TeX("$e_{s}$")   )
plot(Datosfit$Xprima, Datosfit$.std.resid, xlab = TeX("$X'$"), ylab=TeX("$e_{s}$")   )
### Usamos los residuales (errores observados) al cuadrado
Datosfit$res2=Datosfit$.resid^2
par(mar=c(4, 5, 1, 1))
par(mfrow=c(1,2))
plot(Datosfit$Xprima, Datosfit$res2, xlab = TeX("$X'$"), ylab=TeX("$e^{2}$") )
plot(Datosfit$Xprima^2, Datosfit$res2, xlab = TeX("$X'^2$"), ylab=TeX("$e^{2}$") )
library(tidyverse)
DatosfitAgrup= Datosfit %>% group_by(Xprima) %>% summarise(res2media=mean(res2))
par(mar=c(4, 5, 1, 1))
par(mfrow=c(1,2))
plot(DatosfitAgrup$Xprima, DatosfitAgrup$res2media, xlab = TeX("$X'$"), ylab=TeX("$e^{2}$") )
plot(DatosfitAgrup$Xprima^2, DatosfitAgrup$res2media, xlab = TeX("$X'^2$"), ylab=TeX("$e^{2}$") )
fitpond <- lm(salary~Xprima,weights = 1/(Xprima), data=Datos)
summary(fitpond)
par(mfrow=c(1,1))
par(mar=c(4, 5, 1, 1))
plot(fitpond, 3)
car::ncvTest(fitpond)
library(broom)
Datosfitpond=augment(fitpond)
head(Datosfitpond)
par(mar=c(4, 5, 1, 1))
par(mfrow=c(1,2))
plot(Datosfitpond$.fitted, Datosfitpond$.std.resid, xlab = TeX("$\\widehat{y}$"), ylab=TeX("$e_{s}$")   )
plot(Datosfitpond$Xprima, Datosfitpond$.std.resid, xlab = TeX("$X'$"), ylab=TeX("$e_{s}$")   )
fitpond2 <- lm(salary~Xprima,weights = 1/(Xprima^2), data=Datos)
summary(fitpond2)
par(mfrow=c(1,1))
par(mar=c(4, 5, 1, 1))
plot(fitpond2, 3)
car::ncvTest(fitpond2)
library(broom)
Datosfitpond2=augment(fitpond2)
head(Datosfitpond2)
par(mar=c(4, 5, 1, 1))
par(mfrow=c(1,2))
plot(Datosfitpond2$.fitted, Datosfitpond2$.std.resid, xlab = TeX("$\\widehat{y}$"), ylab=TeX("$e_{s}$")   )
plot(Datosfitpond2$Xprima, Datosfitpond2$.std.resid, xlab = TeX("$X'$"), ylab=TeX("$e_{s}$")   )
# Gr?fica con resultados
par(mar=c(4, 5, 1, 1))
par(mfrow=c(1,1))
fitpond2y <- function(X2) {fitpond2$coef[1]+ fitpond2$coef[2]*(X2+10)^2}
plot(Datos$years, Datos$salary, xlab = TeX("$X=years$"), ylab=TeX("$salary$") )
curve(fitpond2y, from = min(Datos$years), to = max(Datos$years),
col = "red", add = T)
rm(list = ls(all.names = TRUE))
gc()
rm(list = ls(all.names = TRUE))
gc()
Datos = read.csv("ejemplo4.csv")
head(Datos)
str(Datos)
library(latex2exp)
par(mfrow=c(1,1))
par(mar=c(4, 5, 1, 1))
plot(Datos$x, Datos$y, xlab = TeX("$x$"), ylab=TeX("$y$") )
rm(list = ls(all.names = TRUE))
gc()
### Continuaci?n de ejemplo. Compa??a Toluca
### Verificaci?n sobre linealidad.
library(latex2exp)
library(ALSM)
Datos=TolucaCompany
head(Datos)
str(Datos)
par(mfrow=c(1,1))
par(mar=c(4, 5, 1, 1))
plot(Datos$x, Datos$y, xlab = TeX("$x$"), ylab=TeX("$y$") )
fit=lm(y~x, data=Datos)
summary(fit)
#R tiene una funci?n para obtener errores de forma automatizada
library(broom)
Datosfit=augment(fit)
head(Datosfit)
par(mar=c(4, 5, 1, 1))
par(mfrow=c(1,2))
plot(Datosfit$.fitted, Datosfit$.resid, xlab = TeX("$\\widehat{y}$"), ylab=TeX("$e$")   )
plot(Datos$x, Datosfit$.resid, xlab = TeX("$X$"), ylab=TeX("$e$") )
#R tiene una gr?fica propia para verificar linealidad
par(mfrow=c(1,1))
par(mar=c(4, 5, 1, 1))
plot(fit, 1)
# Se requiere que x sea positiva
library(car)
boxTidwell(y~x, data=Datos)
#Donde Pr(>|z|) corresponde al pvalue asociado al contraste:
#Donde Pr(>|z|) corresponde al pvalue asociado al contraste:
#Ho: lambda=1 vs Ha:lambda != 1.
#Donde Pr(>|z|) corresponde al pvalue asociado al contraste:
#Ho: lambda=1 vs Ha:lambda != 1.
#Si no se rechaza, entonces es plausible considerar el modelo con X directamente
rm(list = ls(all.names = TRUE))
gc()
### Continuaci?n de ejemplo. Compa??a Toluca
### Verificaci?n sobre linealidad.
library(latex2exp)
library(ALSM)
rm(list = ls(all.names = TRUE))
gc()
### Continuaci?n de ejemplo. Compa??a Toluca
### Verificaci?n sobre linealidad.
library(latex2exp)
library(ALSM)
Datos=TolucaCompany
head(Datos)
str(Datos)
par(mfrow=c(1,1))
par(mar=c(4, 5, 1, 1))
plot(Datos$x, Datos$y, xlab = TeX("$x$"), ylab=TeX("$y$") )
fit=lm(y~x, data=Datos)
summary(fit)
#R tiene una funci?n para obtener errores de forma automatizada
library(broom)
Datosfit=augment(fit)
head(Datosfit)
par(mar=c(4, 5, 1, 1))
par(mfrow=c(1,2))
plot(Datosfit$.fitted, Datosfit$.resid, xlab = TeX("$\\widehat{y}$"), ylab=TeX("$e$")   )
plot(Datos$x, Datosfit$.resid, xlab = TeX("$X$"), ylab=TeX("$e$") )
#R tiene una gr?fica propia para verificar linealidad
par(mfrow=c(1,1))
par(mar=c(4, 5, 1, 1))
plot(fit, 1)
# Se requiere que x sea positiva
library(car)
boxTidwell(y~x, data=Datos)
#Donde Pr(>|z|) corresponde al pvalue asociado al contraste:
#Donde Pr(>|z|) corresponde al pvalue asociado al contraste:
#Ho: lambda=1 vs Ha:lambda != 1.
#Donde Pr(>|z|) corresponde al pvalue asociado al contraste:
#Ho: lambda=1 vs Ha:lambda != 1.
#Si no se rechaza, entonces es plausible considerar el modelo con X directamente
#Donde Pr(>|z|) corresponde al pvalue asociado al contraste:
#Ho: lambda=1 vs Ha:lambda != 1.
#Si no se rechaza, entonces es plausible considerar el modelo con X directamente
#Si se rechaza, entonces conviene usar el estimador de lambda para transformar X
rm(list = ls(all.names = TRUE))
gc()
### Continuación de ejemplo. Compañía Toluca
### Verificación sobre linealidad.
library(latex2exp)
library(ALSM)
Datos=TolucaCompany
head(Datos)
str(Datos)
par(mfrow=c(1,1))
par(mar=c(4, 5, 1, 1))
plot(Datos$x, Datos$y, xlab = TeX("$x$"), ylab=TeX("$y$") )
fit=lm(y~x, data=Datos)
summary(fit)
#R tiene una función para obtener errores de forma automatizada
library(broom)
Datosfit=augment(fit)
head(Datosfit)
par(mar=c(4, 5, 1, 1))
par(mfrow=c(1,2))
plot(Datosfit$.fitted, Datosfit$.resid, xlab = TeX("$\\widehat{y}$"), ylab=TeX("$e$")   )
plot(Datos$x, Datosfit$.resid, xlab = TeX("$X$"), ylab=TeX("$e$") )
#R tiene una gráfica propia para verificar linealidad
par(mfrow=c(1,1))
par(mar=c(4, 5, 1, 1))
plot(fit, 1)
# Se requiere que x sea positiva
library(car)
boxTidwell(y~x, data=Datos)
#Donde Pr(>|z|) corresponde al pvalue asociado al contraste:
#Donde Pr(>|z|) corresponde al pvalue asociado al contraste:
#Ho: lambda=1 vs Ha:lambda != 1.
#Donde Pr(>|z|) corresponde al pvalue asociado al contraste:
#Ho: lambda=1 vs Ha:lambda != 1.
#Si no se rechaza, entonces es plausible considerar el modelo con X directamente
rm(list = ls(all.names = TRUE))
gc()
Datos = read.csv("ejemplo4.csv")
head(Datos)
str(Datos)
library(latex2exp)
par(mfrow=c(1,1))
par(mar=c(4, 5, 1, 1))
plot(Datos$x, Datos$y, xlab = TeX("$x$"), ylab=TeX("$y$") )
fit=lm(y~x, data=Datos)
summary(fit)
#R tiene una gr?fica propia para verificar linealidad
par(mfrow=c(1,1))
par(mar=c(4, 5, 1, 1))
plot(fit, 1)
###Buscamos una posible transformaci?n
library(car)
boxTidwell(y~x, data=Datos)
#La salida es el estimador de la potencia 1.98 aprox 2
#Test Ho: lambda=1 vs Ha:lambda != 1.
#Si no se rechaza, entonces es plausible considerar el modelo con X directamente
#Si se rechaza, entonces conviene usar el estimador de lambda para transformar X
# u otra transformaci?n
#Aqu? se rechaza H0.
Datos$Xprima=Datos$x^2
fit2=lm(y~Xprima, data=Datos)
summary(fit2)
#R tiene una gr?fica propia para verificar linealidad
par(mfrow=c(1,1))
par(mar=c(4, 5, 1, 1))
plot(fit2, 1)
boxTidwell(y~Xprima, data=Datos)
#Homocedasticidad
par(mfrow=c(1,1))
par(mar=c(4, 5, 1, 1))
plot(fit2, 3)
library(lmtest)
lmtest::bptest(fit2)
summary(powerTransform(fit2))
install.packages("car")
install.packages("car")
install.packages("car")
install.packages("car")
install.packages("lmtest")
rm(list = ls(all.names = TRUE))
gc()
setwd("~/GitHub/Notas 2024-2/MNPyR")
Datos = read.csv("ejemplo4.csv")
head(Datos)
str(Datos)
library(latex2exp)
par(mfrow=c(1,1))
par(mar=c(4, 5, 1, 1))
plot(Datos$x, Datos$y, xlab = TeX("$x$"), ylab=TeX("$y$") )
fit=lm(y~x, data=Datos)
summary(fit)
#R tiene una gr?fica propia para verificar linealidad
par(mfrow=c(1,1))
par(mar=c(4, 5, 1, 1))
plot(fit, 1)
###Buscamos una posible transformaci?n
library(car)
boxTidwell(y~x, data=Datos)
#La salida es el estimador de la potencia 1.98 aprox 2
#Test Ho: lambda=1 vs Ha:lambda != 1.
#Si no se rechaza, entonces es plausible considerar el modelo con X directamente
#Si se rechaza, entonces conviene usar el estimador de lambda para transformar X
# u otra transformaci?n
#Aqu? se rechaza H0.
Datos$Xprima=Datos$x^2
fit2=lm(y~Xprima, data=Datos)
summary(fit2)
#R tiene una gr?fica propia para verificar linealidad
par(mfrow=c(1,1))
par(mar=c(4, 5, 1, 1))
plot(fit2, 1)
boxTidwell(y~Xprima, data=Datos)
#Homocedasticidad
par(mfrow=c(1,1))
par(mar=c(4, 5, 1, 1))
plot(fit2, 3)
library(lmtest)
lmtest::bptest(fit2)
summary(powerTransform(fit2))
rm(list = ls(all.names = TRUE))
gc()
setwd("~/GitHub/Notas 2024-2/MNPyR")
Datos = read.csv("initech.csv")
head(Datos)
str(Datos)
library(latex2exp)
par(mfrow=c(1,2))
par(mar=c(4, 5, 1, 1))
plot(Datos$years, Datos$salary, xlab = TeX("$X=years$"), ylab=TeX("$salary$") )
plot((Datos$years+10)^2, Datos$salary, xlab = TeX("$X'=(years+10)^2$"), ylab=TeX("$salary$") )
Datos$Xprima=(Datos$years+10)^2
fit=lm(salary~Xprima, data=Datos)
summary(fit)
par(mfrow=c(1,1))
par(mar=c(4, 5, 1, 1))
plot(fit, 3)
lmtest::bptest(fit)
car::ncvTest(fit)
library(broom)
Datosfit=augment(fit)
head(Datosfit)
par(mar=c(4, 5, 1, 1))
par(mfrow=c(1,2))
plot(Datosfit$.fitted, Datosfit$.std.resid, xlab = TeX("$\\widehat{y}$"), ylab=TeX("$e_{s}$")   )
plot(Datosfit$Xprima, Datosfit$.std.resid, xlab = TeX("$X'$"), ylab=TeX("$e_{s}$")   )
### Usamos los residuales (errores observados) al cuadrado
Datosfit$res2=Datosfit$.resid^2
par(mar=c(4, 5, 1, 1))
par(mfrow=c(1,2))
plot(Datosfit$Xprima, Datosfit$res2, xlab = TeX("$X'$"), ylab=TeX("$e^{2}$") )
plot(Datosfit$Xprima^2, Datosfit$res2, xlab = TeX("$X'^2$"), ylab=TeX("$e^{2}$") )
library(tidyverse)
DatosfitAgrup= Datosfit %>% group_by(Xprima) %>% summarise(res2media=mean(res2))
par(mar=c(4, 5, 1, 1))
par(mfrow=c(1,2))
plot(DatosfitAgrup$Xprima, DatosfitAgrup$res2media, xlab = TeX("$X'$"), ylab=TeX("$e^{2}$") )
plot(DatosfitAgrup$Xprima^2, DatosfitAgrup$res2media, xlab = TeX("$X'^2$"), ylab=TeX("$e^{2}$") )
fitpond <- lm(salary~Xprima,weights = 1/(Xprima), data=Datos)
summary(fitpond)
par(mfrow=c(1,1))
par(mar=c(4, 5, 1, 1))
plot(fitpond, 3)
car::ncvTest(fitpond)
library(broom)
Datosfitpond=augment(fitpond)
head(Datosfitpond)
par(mar=c(4, 5, 1, 1))
par(mfrow=c(1,2))
plot(Datosfitpond$.fitted, Datosfitpond$.std.resid, xlab = TeX("$\\widehat{y}$"), ylab=TeX("$e_{s}$")   )
plot(Datosfitpond$Xprima, Datosfitpond$.std.resid, xlab = TeX("$X'$"), ylab=TeX("$e_{s}$")   )
fitpond2 <- lm(salary~Xprima,weights = 1/(Xprima^2), data=Datos)
summary(fitpond2)
par(mfrow=c(1,1))
par(mar=c(4, 5, 1, 1))
plot(fitpond2, 3)
car::ncvTest(fitpond2)
library(broom)
Datosfitpond2=augment(fitpond2)
head(Datosfitpond2)
par(mar=c(4, 5, 1, 1))
par(mfrow=c(1,2))
plot(Datosfitpond2$.fitted, Datosfitpond2$.std.resid, xlab = TeX("$\\widehat{y}$"), ylab=TeX("$e_{s}$")   )
plot(Datosfitpond2$Xprima, Datosfitpond2$.std.resid, xlab = TeX("$X'$"), ylab=TeX("$e_{s}$")   )
# Gr?fica con resultados
par(mar=c(4, 5, 1, 1))
par(mfrow=c(1,1))
fitpond2y <- function(X2) {fitpond2$coef[1]+ fitpond2$coef[2]*(X2+10)^2}
plot(Datos$years, Datos$salary, xlab = TeX("$X=years$"), ylab=TeX("$salary$") )
curve(fitpond2y, from = min(Datos$years), to = max(Datos$years),
col = "red", add = T)
# Dado que aqu? no se transform? a y, la recta corresponde a la estimaci?n
# Dado que aqu? no se transform? a y, la recta corresponde a la estimaci?n
# de E(y;x).
# Dado que aqu? no se transform? a y, la recta corresponde a la estimaci?n
# de E(y;x).
# Dado que aqu? no se transform? a y, la recta corresponde a la estimaci?n
# de E(y;x).
install.packages("Ecdat")
rm(list = ls(all.names = TRUE))
gc()
library(Ecdat)
Datos <- University
help(University)
head(Datos)
str(Datos)
library(latex2exp)
par(mfrow=c(1,1))
par(mar=c(4, 5, 1, 1))
plot(Datos$stfees, Datos$nassets, xlab = TeX("$stfees$"), ylab=TeX("$nassets$") )
fit=lm(nassets~stfees, data=Datos)
summary(fit)
par(mfrow=c(1,1))
par(mar=c(4, 5, 1, 1))
plot(fit, 3)
library(broom)
Datosfit=augment(fit)
head(Datosfit)
par(mar=c(4, 5, 1, 1))
par(mfrow=c(1,1))
plot(Datosfit$.fitted, Datosfit$.std.resid, xlab = TeX("$\\widehat{y}$"), ylab=TeX("$e_{s}$")   )
### Pruebas de hipótesis
### H0: varianza no depende de forma lineal en x vs  Ha: varianza depende de forma lineal en x
### Se busca no rechazar, es decir,
### que sea plausible (no se encontró evidencia en contra) asumir que la varianza no depende de forma lineal de x
### i.e. p-value mayor a significancia.
#Usa residuales studentilizados
library(lmtest)
lmtest::bptest(fit)
#Usa residuales estandarizados
library(car)
car::ncvTest(fit)
summary(Datos$nassets)
#Se prefiere un valor de lambda conocido para no complicar mucho la interpretaci?n
summary(powerTransform(fit))
Datos$nassets_lambda0=bcPower(Datos$nassets, .2)
Datos$nassetsBC=(Datos$nassets^(.2)-1)/.2
par(mar=c(4, 5, 1, 1))
par(mfrow=c(1,1))
plot(Datos$stfees, Datos$nassetsBC, xlab = TeX("$stfees$"), ylab=TeX("$(y^{.2}-1)/.2$") )
fit2=lm(nassetsBC~stfees, data=Datos)
summary(fit2)
par(mfrow=c(1,1))
par(mar=c(4, 5, 1, 1))
plot(fit2, 3)
lmtest::bptest(fit2)
car::ncvTest(fit2)
summary(powerTransform(fit2))
#Para datos negativos o con ceros se puede usar una constante gamma positiva para trabajar con valores positivos
#powerTransform(,  family="bcnPower")
summary(powerTransform(fit,  family="bcnPower"))
Datos$nassetsBCalt=bcnPower(Datos$nassets, lambda=0, gamma=16677.21)
fit3=lm(nassetsBCalt~stfees, data=Datos)
plot(Datos$stfees, Datos$nassetsBCalt, xlab = TeX("$stfees$"), ylab=TeX("$ln(z)$") )
plot(fit3, 3)
lmtest::bptest(fit3)
car::ncvTest(fit3)
par(mfrow=c(1,2))
par(mar=c(4, 5, 1, 1))
fit2yprima <- function(X2) {fit2$coef[1]+ fit2$coef[2]*X2}
fit2y <- function(X2) {((fit2$coef[1]+ fit2$coef[2]*X2)*.2+1)^5}
# En la escala transformada la curva (recta) corresponde
# a la estimación de E(y*;x)=Med(y*;x)
plot(Datos$stfees,Datos$nassetsBC, xlab = TeX("$stfees$"), ylab=TeX("$y^{*}$") )
curve(fit2yprima, from = min(Datos$stfees), to = max(Datos$stfees),
col = "red", add = T)
# En la escala original la curva corresponde
# a la estimación de Med(y;x)
plot(Datos$stfees, Datos$nassets, xlab = TeX("$stfees$"), ylab=TeX("$nassets$") )
curve(fit2y, from = min(Datos$stfees), to = max(Datos$stfees),
col = "red", add = T)
